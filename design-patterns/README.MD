# Design Patterns in Software Engineering ğŸ’»

Design patterns are **reusable solutions** to common software design problems. They help improve code readability, scalability, and maintainability. Below are the key **types** of design patterns, explained in a simple and concise way.

---

## Types of Design Patterns ğŸ› ï¸

### 1. **Creational Patterns** ğŸŒ±
Creational patterns deal with object creation mechanisms. They abstract the instantiation process and provide flexibility.

- **Singleton** ğŸ§‘â€ğŸ¤â€ğŸ§‘: Ensures a class has only one instance.
- **Factory Method** ğŸ­: Creates objects without specifying the exact class.
- **Abstract Factory** ğŸ­ğŸ› ï¸: Creates families of related objects.
- **Builder** ğŸ› ï¸: Constructs complex objects step-by-step.
- **Prototype** ğŸ§³: Creates new objects by copying an existing one.

### 2. **Structural Patterns** ğŸ—ï¸
These patterns deal with how classes and objects are composed to form larger structures.

- **Adapter** ğŸ”Œ: Converts one interface to another.
- **Bridge** ğŸŒ‰: Decouples abstraction and implementation.
- **Composite** ğŸŒ¿: Allows single objects and compositions of objects to be treated uniformly.
- **Decorator** ğŸ¨: Adds functionality to an object dynamically.
- **Facade** ğŸ¢: Provides a simplified interface to a complex subsystem.
- **Flyweight** ğŸ’¨: Reduces memory usage by sharing common objects.
- **Proxy** ğŸ›¡ï¸: Provides a surrogate or placeholder for another object.

### 3. **Behavioral Patterns** ğŸ§ 
Behavioral patterns focus on the interaction and responsibility of objects.

- **Observer** ğŸ‘€: Notifies multiple objects when one object changes.
- **Strategy** âš™ï¸: Allows selecting a method at runtime.
- **Command** ğŸ“œ: Encapsulates a request as an object.
- **State** ğŸ: Changes an objectâ€™s behavior based on its state.
- **Chain of Responsibility** ğŸ”—: Passes a request along a chain of handlers.
- **Mediator** ğŸ—£ï¸: Centralizes communication between objects.
- **Memento** ğŸ“¸: Captures the state of an object for later restoration.
- **Template Method** ğŸ“: Defines steps of an algorithm, allowing flexibility in steps.
- **Iterator** ğŸ§­: Iterates over elements in a collection.
- **Visitor** ğŸ§‘â€ğŸ”¬: Allows adding operations without changing the objects.

---

## Why Use Design Patterns? ğŸ¤”

- **Code Reusability**: Write once, use many times.
- **Maintainability**: Simplifies updates and bug fixes.
- **Efficiency**: Reduces the time needed to solve common design problems.
- **Scalability**: Easily scale applications using established patterns.
- **Communication**: Developers can quickly understand each other by referring to known patterns.

---

## Example: Singleton Pattern ğŸ§‘â€ğŸ¤â€ğŸ§‘

Here is an example of the **Singleton** pattern:

```javascript
class Singleton {
    constructor() {
        if (Singleton.instance) {
            return Singleton.instance; // Return the existing instance
        }\
        this.value = Math.random(); // Assign a random value to the instance
        Singleton.instance = this; // Store the instance
    }

    getValue() {
        return this.value;
    }
}

const instance1 = new Singleton();
const instance2 = new Singleton();

console.log(instance1.getValue()); // Same value as instance2
console.log(instance1 === instance2); // true (both are the same instance)
\